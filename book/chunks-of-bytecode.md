> å¦‚æœä½ å‘ç°è‡ªå·±å‡ ä¹æŠŠæ‰€æœ‰æ—¶é—´éƒ½èŠ±åœ¨äº†ç†è®ºä¸Šé¢ï¼Œé‚£ä¹ˆæŠŠä½ çš„æ³¨æ„åŠ›è½¬å‘å®è·µå§ï¼Œè¿™ä¼šæå‡ä½ çš„ç†è®ºæ°´å¹³ã€‚å¦‚æœä½ å‘ç°è‡ªå·±å‡ ä¹æŠŠæ‰€æœ‰çš„æ—¶é—´éƒ½èŠ±åœ¨äº†å®è·µä¸Šï¼Œé‚£ä¹ˆæŠŠä½ çš„æ³¨æ„åŠ›è½¬å‘ç†è®ºå§ï¼Œè¿™ä¼šæå‡ä½ çš„å®è·µæ°´å¹³ã€‚
>
> <cite>é«˜å¾·çº³</cite>

æˆ‘ä»¬å·²ç»å®Œæˆäº†ä¸€ä¸ªLoxçš„è§£é‡Šå™¨jloxï¼Œé‚£ä¸ºä»€ä¹ˆè¿™æœ¬ä¹¦è¿˜æ²¡æœ‰ç»“æŸå‘¢ï¼Ÿéƒ¨åˆ†åŸå› æ˜¯å› ä¸ºjloxçš„å®ç°ä¸¥é‡çš„ä¾èµ–äº†<span name="metal">JVMè™šæ‹Ÿæœº</span>ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦ä»æ ¹å„¿ä¸Šé€å½»ç†è§£è§£é‡Šå™¨çš„å·¥ä½œåŸç†ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ç‚¹ä¸€æ»´çš„æ„å»ºä¸€ä¸ªè§£é‡Šå™¨å‡ºæ¥ï¼Œè€Œä¸æ˜¯ä¾èµ–åˆ«çš„å·¥å…·ï¼ˆä¾‹å¦‚JVMï¼‰ã€‚

<aside name="metal">

å½“ç„¶äº†ï¼Œæˆ‘ä»¬çš„ç¬¬äºŒä¸ªè§£é‡Šå™¨ä¾èµ–äºCæ ‡å‡†åº“ï¼Œæ¥å®Œæˆåƒå†…å­˜åˆ†é…è¿™æ ·çš„åŸºç¡€å·¥ä½œã€‚Cç¼–è¯‘å™¨æŠŠæˆ‘ä»¬ä»åº•å±‚çš„æœºå™¨è¯­è¨€ä¸­è§£æ”¾äº†å‡ºæ¥ï¼ˆç¨‹åºæœ€åéƒ½ä¼šè½¬æ¢æˆæœºå™¨è¯­è¨€æ‰§è¡Œï¼‰ã€‚è€Œæœºå™¨è¯­è¨€åˆæ˜¯ç”±èŠ¯ç‰‡ä¸Šçš„ç¼–ç¨‹è¯­è¨€å®ç°çš„ï¼ˆä¾‹å¦‚Verilogï¼‰ã€‚è€ŒCè¯­è¨€çš„è¿è¡Œæ—¶ä¾èµ–äºæ“ä½œç³»ç»Ÿè¿›è¡Œå†…å­˜åˆ†é…ï¼ˆå¯ä»¥å‚è€ƒã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹æ¥å­¦ä¹ è™šæ‹Ÿå†…å­˜çš„æœºåˆ¶ï¼‰ã€‚ä½†æˆ‘ä»¬å¿…é¡»*åœä¸‹æ¥*ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å‘åº•å±‚æ·±æŒ–åªèƒ½åœç•™åœ¨Cè¯­è¨€è¿™ä¸€æ­¥äº†ï¼Œè¦ä¸ç„¶ä½ æ•´ä¸ªä¹¦æ¶éƒ½æ”¾ä¸ä¸‹è¿™æœ¬ä¹¦äº†ã€‚

</aside>

ä¸€ä¸ªæ›´åŠ åŸºæœ¬çš„åŸå› æ˜¯ï¼Œjloxçš„è¿è¡Œé€Ÿåº¦å®åœ¨æ˜¯å¤ªæ…¢äº†ã€‚æ ‘éå†è§£é‡Šå™¨å¯¹äºæŸäº›é«˜å±‚çš„å£°æ˜å¼çš„è¯­è¨€ï¼ˆä¾‹å¦‚SQLï¼‰æ¥è¯´è¶³å¤Ÿäº†ï¼Œä½†å¯¹äºä¸€é—¨é€šç”¨çš„å‘½ä»¤å¼çš„ç¼–ç¨‹è¯­è¨€æ¥è¯´â€”â€”å³ä½¿æ˜¯åƒLoxè¿™æ ·çš„è„šæœ¬è¯­è¨€ï¼Œä¹Ÿæ˜¯å®Œå…¨ä¸å¤Ÿç”¨çš„ã€‚ä¾‹å¦‚ä¸‹é¢çš„è¿™æ®µå°è„šæœ¬ç¨‹åºï¼š

```lox
fun fib(n) {
  if (n < 2) return n;
  return fib(n - 1) + fib(n - 2); // [fib]
}

var before = clock();
print fib(40);
var after = clock();
print after - before;
```

<aside name="fib">

ä¸Šé¢çš„ç¨‹åºæ˜¯ä¸€ç§éå¸¸ä½æ•ˆçš„è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„æ–¹æ³•ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç”¨ä¸Šé¢çš„ç¨‹åºæ¥æµ‹è¯•*è§£é‡Šå™¨*çš„è¿è¡Œé€Ÿåº¦ï¼Œè€Œä¸æ˜¯å†™ä¸€ä¸ªé«˜æ•ˆçš„æ–æ³¢é‚£å¥‘æ•°åˆ—çš„è®¡ç®—ç¨‹åºã€‚ä¸€ä¸ªåšäº†å¾ˆå¤šäº‹æƒ…çš„å¾ˆæ…¢çš„ç¨‹åºâ€”â€”å¯èƒ½æ¯«æ— æ„ä¹‰â€”â€”ä½†å´æ˜¯è§£é‡Šå™¨è¿è¡Œé€Ÿåº¦çš„ä¸€ä¸ªå¾ˆå¥½çš„æµ‹è¯•ç”¨ä¾‹ã€‚

</aside>

åœ¨æˆ‘çš„ç¬”è®°æœ¬ç”µè„‘ä¸Šï¼Œä½¿ç”¨jloxæ¥è¿è¡Œè¿™æ®µç¨‹åºï¼Œéœ€è¦72ç§’ã€‚è€ŒåŒæ ·é€»è¾‘çš„Cç¨‹åºï¼Œåªéœ€è¦0.5ç§’ã€‚æˆ‘ä»¬æ„å»ºçš„åŠ¨æ€ç±»å‹è„šæœ¬è¯­è¨€ä»æ¥æ²¡æƒ³è¿‡å’Œæ‰‹åŠ¨ç®¡ç†å†…å­˜çš„é™æ€ç±»å‹è¯­è¨€Cçš„è¿è¡Œé€Ÿåº¦ä¸€æ ·å¿«ã€‚ä½†æ˜¯ä¹Ÿä¸èƒ½æ…¢å‡º*ä¸¤ä¸ªæ•°é‡çº§*å»å•Šã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ€§èƒ½åˆ†æå™¨ï¼ˆprofilerï¼‰æ¥åˆ†ææˆ‘ä»¬å†™çš„jloxè§£é‡Šå™¨ï¼Œç„¶åå¼€å§‹è°ƒä¼˜ï¼Œæ¯”å¦‚æ‰¾å‡ºçƒ­ç‚¹ï¼ˆé¢‘ç¹è¿è¡Œçš„ä»£ç ï¼‰ä»£ç è¿›è¡Œä¼˜åŒ–ï¼Œä½†å³ä½¿è¿™æ ·ï¼Œæˆ‘ä»¬ä¹Ÿèµ°ä¸è¿œã€‚å› ä¸ºæ‰§è¡Œæ¨¡å‹â€”â€”éå†æŠ½è±¡è¯­æ³•æ ‘â€”â€”ä»æ ¹å„¿ä¸Šå°±æ˜¯ä¸ªé”™è¯¯çš„è®¾è®¡ã€‚æˆ‘ä»¬åœ¨è¿™ä¸ªæ¨¡å‹ä¹‹ä¸Šè¿›è¡Œä¼˜åŒ–ï¼Œæ— è®ºå†æ€ä¹ˆä¼˜åŒ–ï¼Œæ€§èƒ½éƒ½ä¸ä¼šå¾ˆå¥½ã€‚å°±å¥½æ¯”æ— è®ºå¦‚ä½•ï¼Œæˆ‘ä»¬ä¹Ÿä¸å¯èƒ½å°†ä¸€å°è½¿è½¦ä¼˜åŒ–æˆä¸€è¾†æˆ˜æ–—æœºã€‚

æˆ‘ä»¬éœ€è¦é‡æ–°æ€è€ƒä¸€ä¸‹æ ¸å¿ƒæ¨¡å‹ã€‚æœ¬ç« å°†ä»‹ç»ä¸€ä¸ªæ–°æ‰§è¡Œæ¨¡å‹ä»¥åŠå­—èŠ‚ç ï¼Œç„¶åå¼€å§‹ç¼–å†™æˆ‘ä»¬çš„æ–°è§£é‡Šå™¨ï¼šcloxã€‚

## å­—èŠ‚ç ï¼Ÿ

åœ¨å·¥ç¨‹ä¸­ï¼Œå¾ˆå°‘æœ‰é€‰æ‹©æ˜¯ä¸åšå¦¥åï¼ˆtrade-offï¼‰çš„ã€‚æƒ³è¦ç†è§£æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦é€‰æ‹©å­—èŠ‚ç è™šæ‹Ÿæœºè¿™ç§å®ç°æ–¹å¼ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å…¶ä»–é€‰é¡¹ã€‚

### ä¸ºä»€ä¹ˆä¸é‡‡ç”¨éå†æŠ½è±¡è¯­æ³•æ ‘çš„æ–¹å¼ï¼Ÿ

æˆ‘ä»¬ä¹‹å‰å†™çš„è§£é‡Šå™¨å·²ç»åšäº†è¿™æ ·çš„äº‹æƒ…ï¼š

*   é¦–å…ˆï¼Œæˆ‘ä»¬å·²ç»é‡‡ç”¨éå†æŠ½è±¡è¯­æ³•æ ‘çš„æ–¹å¼å†™äº†ä¸€ä¸ªè§£é‡Šå™¨ã€‚æ‰€ä»¥åˆ°æ­¤ä¸ºæ­¢å§ï¼Œåˆ«å†ç”¨è¿™ç§æ–¹æ³•å†æ¥ä¸€éäº†ã€‚ä¸æƒ³å†æ¥ä¸€éçš„æœ€ä¸»è¦çš„åŸå› æ˜¯ï¼Œè¿™ç§é£æ ¼çš„è§£é‡Šå™¨**å®ç°èµ·æ¥éå¸¸ç®€å•**ã€‚ä»£ç çš„è¿è¡Œæ—¶è¡¨ç¤ºå¯ä»¥ç›´æ¥çš„æ˜ å°„åˆ°è¯­æ³•ã€‚ä»è§£æå™¨ï¼ˆparserï¼‰è·å¾—è¿è¡Œæ—¶éœ€è¦çš„æ•°æ®ç»“æ„å‡ ä¹ä¸è´¹ä»»ä½•åŠ›æ°”ã€‚

*   å…¶å®ï¼Œæˆ‘ä»¬ä¹‹å‰å†™çš„è§£é‡Šå™¨æ˜¯**ä¾¿æºçš„**ã€‚æˆ‘ä»¬ä½¿ç”¨äº†Javaæ¥å¼€å‘ï¼Œæ‰€ä»¥å¯ä»¥è¿è¡Œåœ¨Javaæ”¯æŒçš„ä»»æ„å¹³å°ä¸Šã€‚è€Œæˆ‘ä»¬å¯ä»¥ç”¨åŒæ ·çš„æ‰‹æ®µæ¥ç”¨Cå®ç°ä¸€ä¸ªè§£é‡Šå™¨ã€‚ç„¶ååœ¨ä»»æ„å¹³å°ä¸Šè¿è¡Œæˆ‘ä»¬å†™çš„ç¨‹åºï¼ˆCè¯­è¨€ä¹Ÿå¯ä»¥è·¨å¹³å°ï¼‰ã€‚

ä¸Šé¢ä¸¤ç‚¹éƒ½æ˜¯ä¹‹å‰å†™çš„è§£é‡Šå™¨çš„ä¼˜ç‚¹ï¼ˆå®¹æ˜“å®ç°ã€è·¨å¹³å°ï¼‰ã€‚ä½†å¦ä¸€æ–¹é¢ï¼Œ**è¿™ä¸ªè§£é‡Šå™¨å¯¹å†…å­˜çš„è¿ç”¨æ˜¯ä½æ•ˆçš„ã€‚**æ¯ä¸€ä¸ªè¯­æ³•ç‰‡æ®µéƒ½ä¼šè½¬æ¢æˆæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰èŠ‚ç‚¹ã€‚ä¸€ä¸ªå¾ˆè¿·ä½ çš„Loxè¡¨è¾¾å¼ï¼Œä¾‹å¦‚`1 + 2`ï¼Œéƒ½ä¼šè¢«è½¬æ¢æˆä¸€å †Javaå¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡ä¹‹é—´è¿˜æœ‰ä¸€å †æŒ‡é’ˆäº’ç›¸æŒ‡å‘ï¼Œå°±åƒä¸‹é¢è¿™æ ·ï¼š

<span name="header"></span>

<aside name="header">

"(header)"éƒ¨åˆ†æ˜¯Javaè™šæ‹Ÿæœºé’ˆå¯¹æ¯ä¸€ä¸ªå¯¹è±¡è®°å½•çš„ä¸€äº›ä¿¡æ¯ï¼Œè¿™æ ·æ–¹ä¾¿åšå†…å­˜ç®¡ç†å’Œè·Ÿè¸ªå¯¹è±¡çš„ç±»å‹ã€‚è¿™äº›ä¹Ÿå ç©ºé—´å•Šï¼

</aside>

<img src="image/chunks-of-bytecode/ast.png" alt="The tree of Java objects created to represent '1 + 2'." />

ä¸Šå›¾ä¸­çš„æ¯ä¸€ä¸ªæŒ‡é’ˆéƒ½ä¼šç»™å¯¹è±¡å†é™„åŠ 32ä½æˆ–è€…64ä½çš„å­˜å‚¨ç©ºé—´ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå †é‡Œé¢çš„æ•°æ®æ˜¯ä¸€äº›æ¾æ•£é“¾æ¥çš„å¯¹è±¡ï¼Œè¿™å¯¹äº<span name="locality">*ç©ºé—´çš„å±€éƒ¨æ€§*</span>æ˜¯éå¸¸ä¸å¥½çš„æ¶ˆæ¯ã€‚

<aside name="locality">

æœ‰å…³æ•°æ®çš„å±€éƒ¨æ€§ï¼Œæˆ‘åœ¨æˆ‘å†™çš„ç¬¬ä¸€æœ¬ä¹¦ã€Šæ¸¸æˆç¼–ç¨‹æ¨¡å¼ã€‹ä¸­ï¼ŒèŠ±äº†[ä¸€æ•´ç« ][gpp locality]æ¥å†™è¿™ä¸ªè¯é¢˜ã€‚å¦‚æœæƒ³æ·±å…¥äº†è§£ä¸€ä¸‹ï¼Œå¯ä»¥å‚è€ƒã€‚

[gpp locality]: http://gameprogrammingpatterns.com/data-locality.html

</aside>

ç°ä»£CPUå¤„ç†æ•°æ®çš„é€Ÿåº¦è¦æ¯”CPUä»RAMä¸­å–æ•°æ®çš„é€Ÿåº¦å¿«çš„å¤šå¾—å¤šã€‚ä¸ºäº†è¡¥æ•‘è¿™ä¸€ç‚¹ï¼ŒCPUä¸­éƒ½ä¼šæœ‰å¤šçº§ç¼“å­˜ã€‚å¦‚æœå†…å­˜ä¸­çš„ä¸€äº›æ•°æ®å·²ç»åœ¨ç¼“å­˜ä¸­äº†ï¼Œé‚£ä¹ˆè¿™äº›æ•°æ®ä¼šè¢«æ›´å¿«çš„åŠ è½½åˆ°CPUä¸­ï¼ˆæ¯”ä»å†…å­˜ä¸­å–å¿«ï¼‰ã€‚è€Œä¸”è‡³å°‘è¦å¿«*100å€*ã€‚

é‚£ä¹ˆæ•°æ®æ˜¯å¦‚ä½•è¿›å…¥ç¼“å­˜çš„ï¼Ÿæœºå™¨é‡‡ç”¨ä¸€ç§å¯å‘å¼çš„æ–¹æ³•ï¼ˆå°±æ˜¯ç›´è§‰ä¸Šèƒ½æƒ³å‡ºæ¥çš„ï¼‰æ¥æŠŠè¿™äº›äº‹æƒ…æå®šã€‚è¿™ä¸ªå¯å‘å¼æ–¹æ³•éå¸¸ç®€å•ã€‚å½“CPUéœ€è¦è¯»å–RAMä¸­çš„æŸä¸€æ¡æ•°æ®æ—¶ï¼ŒCPUä¼šæŠŠè¿™æ¡æ•°æ®ä»¥åŠè¿™æ¡æ•°æ®åœ¨å†…å­˜ä¸­é™„è¿‘çš„æ•°æ®ï¼ˆé€šå¸¸æ˜¯å†…å­˜ä¸­åŒ…å«è¿™æ¡æ•°æ®çš„ä¸€æ®µæ•°æ®ï¼‰éƒ½è¯»å–åˆ°ç¼“å­˜ä¸­ã€‚

å¦‚æœæˆ‘ä»¬çš„ç¨‹åºæ¥ä¸‹æ¥éœ€è¦è¯·æ±‚çš„æ•°æ®æ˜¯ä¸Šä¸€æ®µè¯æåˆ°çš„é‚£æ¡æ•°æ®é™„è¿‘çš„æ•°æ®ï¼Œç”±äºé‚£æ¡æ•°æ®é™„è¿‘çš„æ•°æ®éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œæˆ‘ä»¬çš„CPUå°±ä¼šåƒå·¥å‚é‡ŒåŠ æ»¡æ²¹çš„ä¼ é€å¸¦ä¸€æ ·ï¼Œå¼€è¶³é©¬åŠ›å·¥ä½œã€‚æˆ‘ä»¬*ç¡®å®*å¾ˆå¸Œæœ›èƒ½å¤Ÿåˆ©ç”¨è¿™ç‚¹ç‰¹æ€§ï¼ˆç©ºé—´å±€éƒ¨æ€§ï¼‰ã€‚ä¸ºäº†é«˜æ•ˆçš„ä½¿ç”¨ç¼“å­˜ï¼Œæˆ‘ä»¬åœ¨å†…å­˜ä¸­è¡¨ç¤ºä»£ç çš„æ–¹å¼å¿…é¡»éå¸¸ç´§å¯†è€Œä¸”æœ‰åºï¼Œæ–¹ä¾¿åˆ©ç”¨ç©ºé—´å±€éƒ¨æ€§ã€‚

ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸Šé¢å›¾ä¸­çš„é‚£ä¸ªæ ‘å½¢ç»“æ„ã€‚é‚£äº›æ ‘å½¢ç»“æ„ä¸­çš„å­ç±»å¯ä»¥å­˜å‚¨åœ¨JVMå †ä¸­çš„<span name="anywhere">ä»»ä½•ä¸€ä¸ªåœ°æ–¹</span>ã€‚éå†æ ‘æ—¶èµ°çš„æ¯ä¸€æ­¥éƒ½ä¼šè·Ÿç€å­©å­èŠ‚ç‚¹å¯¹è±¡çš„å¼•ç”¨èµ°ã€‚è€Œå­©å­èŠ‚ç‚¹æ˜¯å¾ˆå¯èƒ½å­˜å‚¨åœ¨ç¼“å­˜ä¹‹å¤–çš„ï¼ˆå› ä¸ºä¸åœ¨çˆ¶èŠ‚ç‚¹çš„é™„è¿‘ï¼‰ï¼Œè¿™æ ·å°±ä¼šä½¿CPUå¿…é¡»åœ¨RAMä¸­å¯»å€ï¼Œç„¶åä»RAMä¸­å†åŠ è½½ä¸€å—æ•°æ®åˆ°CPUä¸­ã€‚è¿™äº›æ ‘ä¸­çš„èŠ‚ç‚¹ï¼Œç”±äºåœ¨å†…å­˜ä¸­çš„ä½ç½®å¹¶ä¸æŒ¨ç€ï¼Œå› ä¸ºèŠ‚ç‚¹çš„è¿æ¥æ˜¯é€šè¿‡å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰ç›¸è¿çš„ï¼Œæ‰€ä»¥è¿™äº›èŠ‚ç‚¹ä½ è¿›å…¥åˆ°ç¼“å­˜ä¸­ï¼Œå°±æŠŠåˆ«çš„èŠ‚ç‚¹æŒ¤å‡ºå»äº†ï¼Œè¿™æ ·æ¥å›äº’ç›¸æŒ¤ï¼Œä¼šæœ‰å¾ˆå¤šç¼“å­˜å’Œå†…å­˜ä¹‹é—´çš„IOï¼Œæ•ˆç‡å¾ˆä½ä¸‹ã€‚

<aside name="anywhere">

å³ä½¿åœ¨è§£æå™¨ï¼ˆparserï¼‰ç¬¬ä¸€æ¬¡äº§ç”Ÿè¿™äº›æ ‘çš„èŠ‚ç‚¹æ—¶ï¼Œè¿™äº›èŠ‚ç‚¹åœ¨å†…å­˜ä¸­ç¢°å·§æŒ¨åœ¨äº†ä¸€èµ·ï¼ˆæŒ‰é¡ºåºå­˜å‚¨ï¼Œåƒæ•°ç»„ä¸€æ ·ï¼‰ï¼Œç»è¿‡å¥½å‡ è½®çš„åƒåœ¾æ”¶é›†â€”â€”è¿™ä¼šå¼•èµ·å¯¹è±¡åœ¨å†…å­˜ä¸­çš„ç§»åŠ¨â€”â€”è¿™äº›èŠ‚ç‚¹ä¹Ÿä¸ä¼šå­˜æ”¾åœ¨ä¸€èµ·äº†ã€‚

</aside>

è¿˜æœ‰å°±æ˜¯æˆ‘ä»¬åœ¨éå†æŠ½è±¡è¯­æ³•æ ‘æ—¶ï¼Œå¤§é‡çš„ä½¿ç”¨äº†è®¿é—®è€…æ¨¡å¼ï¼Œè¿™äº›éƒ½ä¸åˆ©äºå¯¹ç©ºé—´çš„å±€éƒ¨æ€§çš„ä½¿ç”¨ã€‚æ‰€ä»¥ç©ºé—´çš„å±€éƒ¨æ€§è¿™ä¸€å­˜å‚¨ç»“æ„çš„ä¼˜è‰¯ç‰¹æ€§ï¼Œå€¼å¾—æˆ‘ä»¬é€‰æ‹©ä¸€ç§æ›´å¥½çš„ä»£ç è¡¨ç¤ºï¼ˆä¹Ÿå°±æ˜¯å­—èŠ‚ç ï¼‰ã€‚

### ä¸ºä»€ä¹ˆä¸ç›´æ¥ç¼–è¯‘åˆ°æœºå™¨ç ï¼Ÿ

å¦‚æœä½ *çœŸçš„*æƒ³è®©ä½ å†™çš„ä»£ç è¿è¡Œçš„å¾ˆå¿«ï¼Œé‚£ä¹ˆä½ éœ€è¦æŠŠæ‰€æœ‰çš„ä¸­é—´å±‚éƒ½å»æ‰ã€‚è€Œæ˜¯ç›´æ¥ç”Ÿæˆæœºå™¨ç ã€‚*â€œæœºå™¨ç â€*ã€‚å¿µèµ·æ¥å°±å¾ˆå¿«ï¼Œæœ‰æ²¡æœ‰ï¼

ç›´æ¥ç¼–è¯‘åˆ°èŠ¯ç‰‡æ”¯æŒçš„æŒ‡ä»¤é›†æ˜¯é‚£äº›è¿è¡Œæœ€å¿«çš„è¯­è¨€åšçš„äº‹æƒ…ã€‚ç¼–è¯‘åˆ°æœºå™¨ç å¤§æ¦‚æ˜¯æœ€å¿«çš„ä¸€ç§æ‰§è¡Œæ–¹å¼äº†ï¼Œå½“ç„¶å¯èƒ½æ¯”ä¸ä¸Šå¾ˆä¹…ä»¥å‰å·¥ç¨‹å¸ˆä»¬<span name="hand">æ‰‹å†™</span>æœºå™¨è¯­è¨€ç¨‹åºçš„æ—¶å€™å†™å‡ºæ¥çš„ç¨‹åºæ‰§è¡Œçš„å¿«ã€‚

<aside name="hand">

æ˜¯çš„ï¼Œä»–ä»¬çœŸçš„æ˜¯æ‰‹å†™æœºå™¨ç ã€‚åœ¨æ‰“å­”å¡ä¸Šæ‰‹å†™æœºå™¨ç ã€‚ä»–ä»¬æˆ–è®¸ä¼šç”¨*æ‹³å¤´*åœ¨çº¸å¸¦ä¸Šæ‰“å­”ã€‚

</aside>

å¦‚æœä½ ä»æ¥æ²¡å†™è¿‡ä»»ä½•æœºå™¨è¯­è¨€ï¼Œæˆ–è€…å¯è¯»æ€§æ›´åŠ å¥½ä¸€äº›çš„æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘æ¥ç»™ä½ å¤§æ¦‚ä»‹ç»ä¸€ä¸‹å§ã€‚æœºå™¨ç æ˜¯ä¸€ç³»åˆ—æ“ä½œçš„éå¸¸ç´§å¯†çš„åºåˆ—ï¼Œæ˜¯ç›´æ¥ç¼–ç æˆäºŒè¿›åˆ¶çš„ã€‚æ¯ä¸€æ¡æŒ‡ä»¤å ç”¨ä¸€ä¸ªåˆ°å¤šä¸ªå­—èŠ‚çš„é•¿åº¦ï¼Œåº•å±‚åˆ°ä»¤äººéº»æœ¨ï¼ˆä¸€å †0101ï¼‰ã€‚â€œå°†ä¸€ä¸ªå€¼ä»è¿™ä¸ªåœ°å€ç§»åŠ¨åˆ°è¿™ä¸ªå¯„å­˜å™¨ã€‚â€â€œå°†è¿™ä¸¤ä¸ªå¯„å­˜å™¨ä¸­çš„æ•´æ•°ç›¸åŠ ã€‚â€å°±æ˜¯ç±»ä¼¼äºè¿™äº›ä¸œè¥¿ã€‚

CPUä¼šä¸€æ¡ä¸€æ¡çš„æ‰§è¡ŒæŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯ä»å†…å­˜ä¸­è¯»å–æŒ‡ä»¤ï¼Œç„¶åå¯¹æŒ‡ä»¤è¿›è¡Œè§£ç å¹¶æ‰§è¡Œæ¯ä¸€æ¡æŒ‡ä»¤ã€‚æ²¡æœ‰åƒASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰è¿™æ ·çš„æ ‘ç»“æ„ï¼Œæ§åˆ¶æµç»“æ„çš„å®ç°æ˜¯ä»ä»£ç ä¸­çš„ä¸€ä¸ªç‚¹ç›´æ¥è·³è½¬åˆ°å¦ä¸€ç‚¹ã€‚æ²¡æœ‰ä¸­é—´å±‚ï¼Œæ²¡æœ‰ä¸å¿…è¦çš„å¼€é”€ï¼Œæ²¡æœ‰ä¸å¿…è¦çš„ä»£ç çš„è·³è¿‡æˆ–è€…æŒ‡é’ˆçš„æ“ä½œã€‚

è¿è¡Œé€Ÿåº¦å¿«å¦‚é—ªç”µï¼Œä½†è·å¾—è¿™æ ·çš„é«˜æ€§èƒ½å´è¦ä»˜å‡ºä»£ä»·ã€‚é¦–å…ˆï¼Œç¼–è¯‘æˆæœºå™¨ç å¹¶ä¸å®¹æ˜“ã€‚å½“ä»Šå¤§å¤šæ•°è¢«å¹¿æ³›ä½¿ç”¨çš„èŠ¯ç‰‡éƒ½æœ‰ç€æ•°åå¹´æ¥ç§¯ç´¯çš„å¤§é‡æŒ‡ä»¤ï¼ŒèŠ¯ç‰‡æ¶æ„å¦‚æ‹œå åº­å¼å»ºç­‘èˆ¬å¤æ‚ã€‚ä»–ä»¬éœ€è¦å¤æ‚çš„å¯„å­˜å™¨åˆ†é…ç®—æ³•ï¼Œæµæ°´çº¿æŠ€æœ¯ä»¥åŠæŒ‡ä»¤çš„è°ƒåº¦ã€‚

è€Œä¸”ï¼Œå¦‚æœå°†ä»£ç ç¼–è¯‘æˆæœºå™¨ç ï¼Œé‚£æˆ‘ä»¬æ˜¾ç„¶å°±å·²ç»æ”¾å¼ƒäº†<span name ="back">å¯ç§»æ¤æ€§</span>ã€‚èŠ±å‡ å¹´çš„æ—¶é—´æŒæ¡ä¸€äº›å¤æ‚çš„èŠ¯ç‰‡æ¶æ„ï¼Œä½ å¯èƒ½åªèƒ½æŠŠä»£ç ç¼–è¯‘æˆæŸä¸€ç§èŠ¯ç‰‡æŒ‡ä»¤é›†çš„èƒ½åŠ›ã€‚å¦‚æœæƒ³è®©ä½ çš„è¯­è¨€è¿è¡Œåœ¨æ‰€æœ‰çš„èŠ¯ç‰‡æ¶æ„ä¸Šï¼Œæˆ‘ä»¬éœ€è¦æŠŠè¿™äº›èŠ¯ç‰‡çš„æŒ‡ä»¤é›†éƒ½å­¦ä¹ ä¸€éï¼Œç„¶åä¸ºæ¯ä¸€ä¸ªèŠ¯ç‰‡æ¶æ„å†™ä¸€ä¸ªç¼–è¯‘å™¨çš„åç«¯ã€‚

<aside name="back">

å½“ç„¶æƒ…å†µä¹Ÿä¸æ˜¯é‚£ä¹ˆç³Ÿç³•ã€‚ä¸€ä¸ªæ‹¥æœ‰è‰¯å¥½æ¶æ„çš„ç¼–è¯‘å™¨å…è®¸ä½ å…±äº«ç¼–è¯‘å™¨çš„å‰ç«¯ï¼Œä»¥åŠå¤§éƒ¨åˆ†çš„ä¸­é—´å±‚ä¼˜åŒ–ã€‚è¿™äº›éƒ½å¯ä»¥åœ¨ä½ éœ€è¦æ”¯æŒçš„ä¸åŒä½“ç³»ç»“æ„ä¹‹é—´å…±äº«ã€‚æ‰€ä»¥ä¸»è¦å·¥ä½œå°±æ˜¯ä»£ç ç”Ÿæˆï¼Œä»¥åŠæœ‰å…³æŒ‡ä»¤é€‰æ‹©æ–¹é¢çš„ä¸€äº›ç»†èŠ‚ã€‚ä½ å¯èƒ½éœ€è¦å¯¹æ¯ä¸ªæŒ‡ä»¤é›†éƒ½ç¼–å†™ä¸€ä¸‹è¿™äº›å†…å®¹ã€‚

[LLVM][]é¡¹ç›®ä½¿å¾—ä½ è¿ä»£ç ç”Ÿæˆå’ŒæŒ‡ä»¤é€‰æ‹©çš„ç¨‹åºéƒ½ä¸éœ€è¦ç¼–å†™äº†ã€‚å¦‚æœä½ çš„ç¼–è¯‘å™¨è¾“å‡ºçš„æ˜¯LLVMæä¾›çš„ä¸­é—´è¡¨ç¤ºè¯­è¨€ï¼ŒLLVMä¼šç›´æ¥å°†ä½ ç¼–è¯‘å¥½çš„ä¸­é—´è¡¨ç¤ºç¼–è¯‘æˆæŸä¸€ä¸ªä½“ç³»ç»“æ„çš„æœºå™¨ç ã€‚

[llvm]: https://llvm.org/

</aside>

### ä»€ä¹ˆæ˜¯å­—èŠ‚ç ï¼Ÿ

æƒ³ä¸€æƒ³å¦‚ä½•è§£å†³ä¸Šé¢æåˆ°çš„ä¸¤ä¸ªé—®é¢˜ï¼Ÿä¸€æ–¹é¢ï¼Œæ ‘éå†è§£é‡Šå™¨å®ç°èµ·æ¥ç®€å•ï¼Œå¯ç§»æ¤æ€§å¼ºï¼Œä½†è¿è¡Œçš„å¾ˆæ…¢ã€‚å¦ä¸€æ–¹é¢ï¼Œç›´æ¥ç¼–è¯‘åˆ°æœºå™¨ç å®ç°èµ·æ¥å¾ˆå¤æ‚ï¼Œè€Œä¸”ä¸¥é‡å¹³å°ç›¸å…³ï¼Œå¯ç§»æ¤æ€§éå¸¸å·®ï¼Œä½†è¿è¡Œçš„å¾ˆå¿«ã€‚è€Œå­—èŠ‚ç æ­£å¥½å¤„äºä¸¤è€…ä¹‹é—´ã€‚å®ƒä¿ç•™äº†æ ‘éå†è§£é‡Šå™¨çš„å¯ç§»æ¤æ€§â€”â€”æˆ‘ä»¬ä¸éœ€è¦åœ¨æœ¬ä¹¦å†™æ±‡ç¼–è¯­è¨€ã€‚ä¸è¿‡å®ƒä¹Ÿç‰ºç‰²äº†å®ç°ä¸Šé¢çš„ç®€å•æ€§ï¼Œä¸ºäº†è·å–æ€§èƒ½çš„æå‡ï¼Œè¿™æ˜¯å€¼å¾—çš„ã€‚å½“ç„¶æ€§èƒ½å†å¥½ï¼Œä¹Ÿæ¯”ä¸ä¸ŠåŸç”Ÿæœºå™¨ç ã€‚

ä»ç»“æ„ä¸Šçœ‹ï¼Œå­—èŠ‚ç å’Œæœºå™¨ç éå¸¸ç›¸ä¼¼ã€‚å­—èŠ‚ç æ˜¯ç´§å¯†çš„ï¼Œçº¿æ€§çš„äºŒè¿›åˆ¶æŒ‡ä»¤çš„åºåˆ—ã€‚è¿™é™ä½äº†å¼€é”€ï¼Œå¹¶ä¸”é«˜é€Ÿç¼“å­˜å‹å¥½ã€‚å½“ç„¶ï¼Œå­—èŠ‚ç æ¯”èµ·ä»»ä½•çœŸæ­£çš„èŠ¯ç‰‡æŒ‡ä»¤é›†éƒ½è¦ç®€å•çš„å¤šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯æ¯”æ±‡ç¼–æŒ‡ä»¤é›†æ›´åŠ é«˜å±‚æ¬¡çš„æŒ‡ä»¤é›†ã€‚ï¼ˆåœ¨å¾ˆå¤šå­—èŠ‚ç çš„è¡¨ç¤ºå½¢å¼ä¸­ï¼Œæ¯ä¸€æ¡æŒ‡ä»¤åªå ç”¨ä¸€ä¸ªå­—èŠ‚çš„é•¿åº¦ï¼Œæ‰€ä»¥å«â€œå­—èŠ‚ç â€ï¼‰ã€‚

å‡è®¾ä½ åœ¨ç¼–å†™ä¸€ä¸ªæºè¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œç›´æ¥ç¼–è¯‘åˆ°æœºå™¨ç ã€‚è€Œä½ æ­£å¥½æœ‰æƒåŠ›æ¥è®¾è®¡ä½ è¦ç¼–è¯‘åˆ°çš„æœºå™¨ç çš„ä½“ç³»ç»“æ„ã€‚ä½ ä¼šæ€ä¹ˆè®¾è®¡å‘¢ï¼Ÿä½ è‚¯å®šä¼šè®¾è®¡å‡ºä¸€ç§æœ€å®¹æ˜“ç”Ÿæˆçš„æœºå™¨ç ã€‚å­—èŠ‚ç å°±æ˜¯è¿™æ ·çš„è®¾è®¡ã€‚å­—èŠ‚ç æ˜¯ä¸€ç§ç†æƒ³çš„æŒ‡ä»¤é›†ï¼Œè®©ä½ çš„ç¼–è¯‘å™¨ç¼–å†™å·¥ä½œæ›´åŠ è½»æ¾ã€‚

ç†æƒ³çš„ä½“ç³»ç»“æ„æ‰€å­˜åœ¨çš„é—®é¢˜æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿé—®é¢˜å°±æ˜¯å®ƒæ˜¯ç°å®ä¸­ä¸å­˜åœ¨çš„ä½“ç³»ç»“æ„ã€‚æˆ‘ä»¬éœ€è¦ç¼–å†™*æ¨¡æ‹Ÿå™¨ï¼ˆemulatorï¼‰*æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æ¨¡æ‹Ÿå™¨æ˜¯ä¸€ä¸ªä»¿çœŸèŠ¯ç‰‡ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒæ˜¯ä¸€ä¸ªè½¯ä»¶ã€‚æ¨¡æ‹Ÿå™¨ä¼šè§£é‡Šæ‰§è¡Œå­—èŠ‚ç ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡æ‰§è¡Œä¸€æ¡å­—èŠ‚ç ã€‚ä½ ä¹Ÿå¯ä»¥æŠŠæ¨¡æ‹Ÿå™¨å«åš**è™šæ‹Ÿæœºï¼ˆvirtual machineï¼‰**ã€‚

æ¨¡æ‹Ÿå™¨è¿™ä¸€å±‚å¢åŠ äº†ä¸€äº›<span name="p-code">å¼€é”€</span>ï¼Œè¿™ä¸ªä¸­é—´å±‚æ˜¯å­—èŠ‚ç æ¯”åŸç”Ÿæœºå™¨ç æ‰§è¡Œèµ·æ¥æ›´åŠ æ…¢çš„å…³é”®åŸå› ã€‚ä½œä¸ºå›æŠ¥ï¼Œå­—èŠ‚ç ç»™äº†æˆ‘ä»¬å¼ºå¤§çš„å¯ç§»æ¤æ€§ã€‚ä½¿ç”¨Cè¯­è¨€æ¥ç¼–å†™æˆ‘ä»¬çš„è™šæ‹Ÿæœºï¼Œå¯ä»¥è®©æˆ‘ä»¬çš„è™šæ‹Ÿæœºï¼ˆæ¨¡æ‹Ÿå™¨ï¼‰è¿è¡Œåœ¨æ‰€æœ‰çš„ç¡¬ä»¶ä¸Šé¢ã€‚å› ä¸ºå‡ ä¹æ‰€æœ‰çš„ç¡¬ä»¶éƒ½æœ‰Cè¯­è¨€çš„ç¼–è¯‘å™¨ã€‚

<aside name="p-code">

å°¼å¤æ‹‰æ–¯Â·æ²ƒæ–¯ä¸ºPascalè¯­è¨€æ‰€å¼€å‘çš„å­—èŠ‚ç å½¢å¼[p-code][]ï¼Œæ˜¯æœ€æ—©æœŸçš„å­—èŠ‚ç ä¹‹ä¸€ã€‚ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸‹15MHzé¢‘ç‡çš„PDP-11èŠ¯ç‰‡æ˜¯æ— æ³•è´Ÿæ‹…æ¨¡æ‹Ÿæ‰§è¡Œä¸€ä¸ªè™šæ‹Ÿæœºçš„å¼€é”€çš„ã€‚ä½†åœ¨é‚£ä¸ªæ—¶å€™ï¼Œè®¡ç®—æœºæ­£å¤„äºçˆ†ç‚¸å‘å±•çš„æ—¶æœŸï¼Œæ¯å¤©éƒ½æœ‰æ–°çš„ä½“ç³»ç»“æ„å’ŒæŒ‡ä»¤é›†å†’å‡ºæ¥ã€‚æ‰€ä»¥èƒ½å¤Ÿåœ¨æ–°çš„èŠ¯ç‰‡ä¸Šæ‰§è¡Œç¨‹åºæ¯”å»å†™ç¼–è¯‘å™¨å‹æ¦¨æ¯ç§æ–°çš„èŠ¯ç‰‡çš„æé™æ€§èƒ½æ›´åŠ æœ‰ä»·å€¼ã€‚è¿™ä¹Ÿå°±æ˜¯"p"åœ¨"p-code"ä¸­çš„æ„æ€å¹¶ä¸æ˜¯"Pascal"ï¼Œè€Œæ˜¯â€œå¯ç§»æ¤çš„ï¼ˆportableï¼‰â€çš„æ„æ€çš„åŸå› ã€‚

[p-code]: https://en.wikipedia.org/wiki/P-code_machine

</aside>

è€Œè¿™å°±æ˜¯æˆ‘ä»¬çš„æ–°è§£é‡Šå™¨ï¼Œcloxï¼Œå°†è¦èµ°çš„è·¯å¾„ã€‚æˆ‘ä»¬å°†ä¼šè·ŸéšPythonï¼ŒRubyï¼ŒLuaï¼ŒOCamlï¼ŒErlangç­‰è¯­è¨€çš„ä¸»æµå®ç°çš„è„šæ­¥ã€‚åœ¨å¾ˆå¤šæ–¹é¢ï¼Œæˆ‘ä»¬çš„è™šæ‹Ÿæœºçš„è®¾è®¡å’Œä¹‹å‰çš„æ ‘éå†è§£é‡Šå™¨çš„å®ç°æœ‰ç€å¹³è¡Œå’Œå¯¹åº”çš„å…³ç³»ã€‚

<img src="image/chunks-of-bytecode/phases.png" alt="Phases of the two
implementations. jlox is Parser to Syntax Trees to Interpreter. clox is Compiler
to Bytecode to Virtual Machine." />

å½“ç„¶ï¼Œæˆ‘ä»¬ä¸ä¼šä¸¥æ ¼çš„æŒ‰é¡ºåºå®ç°æ¯ä¸€ä¸ªé˜¶æ®µã€‚å°±åƒæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè§£é‡Šå™¨ï¼Œæˆ‘ä»¬ä¼šæ¯æ¬¡å®ç°ä¸€ä¸ªè¯­è¨€çš„ç‰¹æ€§ã€‚åœ¨æœ¬ç« ï¼Œæˆ‘ä»¬å…ˆæ¥æ­ä¸€ä¸ªå†™cloxçš„è„šæ‰‹æ¶ï¼Œä»¥åŠåˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„ç”¨æ¥å­˜å‚¨å’Œè¡¨ç¤ºä¸€å—ï¼ˆchunkï¼‰å­—èŠ‚ç ã€‚

## å¼€å§‹å§ï¼

æˆ‘ä»¬ä»`main()`å‡½æ•°å¼€å§‹å§ï¼<span name="ready">æ‰“å¼€</span>ä½ çš„ç¼–è¾‘å™¨ç„¶åå¼€å§‹æ•²ä»£ç å§ï¼

<aside name="ready">

ç°åœ¨æ˜¯èˆ’å±•è‚Œè‚‰æ‘©æ‹³æ“¦æŒçš„æ—¶å€™äº†ï¼Œæ¥ç‚¹å„¿è’™å¤ªå¥‡éŸ³ä¹ä¹ŸæŒºå¥½ã€‚

</aside>

^code main-c

ä»ä¸Šé¢è¿™ä¸ªå°å°çš„ç§å­å¼€å§‹ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå®Œæ•´çš„è™šæ‹Ÿæœºã€‚ç”±äºCè¯­è¨€ä¸ºæˆ‘ä»¬æä¾›çš„åŠŸèƒ½å¤ªå°‘äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆå¾—åŠ ç‚¹å„¿åœŸã€‚ä¸‹é¢çš„å¤´æ–‡ä»¶é‡Œå°±æ˜¯æˆ‘ä»¬è¦æ·»åŠ çš„ï¼š

^code common-h

åœ¨å®ç°è§£é‡Šå™¨çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¾ˆå¤šçš„ç±»å‹å’Œå¸¸é‡ï¼Œè¿™ä¸ªå¤´æ–‡ä»¶å°±æ˜¯å­˜æ”¾å®ƒä»¬çš„å¥½åœ°æ–¹ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬è¦å­˜æ”¾çš„æ˜¯å¯æ•¬çš„`NULL`ï¼Œ`size_t`ï¼Œä»¥åŠC99æ ‡å‡†å¼•å…¥çš„ç¾å¦™çš„å¸ƒå°”ç±»å‹`bool`ï¼Œè¿˜æœ‰å®šé•¿çš„æ•´å‹ç±»å‹â€”â€”`uint8_t`å’Œå®ƒçš„æœ‹å‹ä»¬ã€‚

## æŒ‡ä»¤çš„å—ï¼ˆchunkï¼‰

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ¨¡å—æ¥å®šä¹‰æˆ‘ä»¬çš„ä»£ç è¡¨ç¤ºå½¢å¼ã€‚æˆ‘æ˜¯ç”¨â€œå—ï¼ˆchunkï¼‰â€è¿™ä¸ªè¯æ¥è¡¨ç¤ºå­—èŠ‚ç åºåˆ—ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç»™è¿™ä¸ªæ¨¡å—èµ·ä¸€ä¸ªåå­—å§ã€‚

^code chunk-h

æˆ‘ä»¬çš„å­—èŠ‚ç ï¼Œæ¯ä¸€æ¡æŒ‡ä»¤å ç”¨ä¸€ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬æŠŠå­—èŠ‚ç çš„æŒ‡ä»¤å«åš**æ“ä½œç ï¼ˆoperation codeï¼‰**ï¼Œç»å¸¸è¢«ç¼©å†™ä¸º**opcode**ã€‚æ“ä½œç çš„æ•°å­—ä»£è¡¨äº†æˆ‘ä»¬è¦æ‰§è¡Œçš„æŒ‡ä»¤â€”â€”ç›¸åŠ ï¼Œç›¸å‡ï¼Œåœ¨ç¬¦å·è¡¨ä¸­æŸ¥è¯¢å˜é‡ï¼Œç­‰ç­‰ã€‚æˆ‘ä»¬åœ¨ä¸‹é¢çš„ä»£ç é‡Œå®šä¹‰æ“ä½œç ï¼š

^code op-enum (1 before, 2 after)

æˆ‘ä»¬å…ˆä»ä¸€æ¡æŒ‡ä»¤`OP_RETURN`å¼€å§‹å§ã€‚å½“æˆ‘ä»¬å®Œæˆæ•´ä¸ªè™šæ‹Ÿæœºçš„ç¼–å†™ä¹‹åï¼Œè¿™æ¡æŒ‡ä»¤çš„æ„æ€æ˜¯â€œä»å½“å‰å‡½æ•°è¿”å›â€ã€‚æˆ‘æ‰¿è®¤è¿™æ¡æŒ‡ä»¤ç°åœ¨è¿˜æ²¡ä»€ä¹ˆç”¨ï¼Œä½†æˆ‘ä»¬æ€»å¾—ä»æŸä¸ªåœ°æ–¹å¼€å§‹å•Šï¼Œè€Œè¿™æ¡æŒ‡ä»¤æ˜¯ä¸€æ¡ç‰¹åˆ«ç®€å•çš„æŒ‡ä»¤ï¼Œæ‰€ä»¥å¾ˆé€‚åˆä»è¿™é‡Œå¼€å§‹ã€‚

### å­˜å‚¨æŒ‡ä»¤çš„åŠ¨æ€æ•°ç»„

å­—èŠ‚ç æ˜¯ä¸€ä¸ªæŒ‡ä»¤åºåˆ—ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™äº›æŒ‡ä»¤è¿åŒå…¶ä»–çš„ä¸€äº›æ•°æ®ä¿å­˜ä¸‹æ¥ã€‚è®©æˆ‘ä»¬æ¥åˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„æ¥å­˜å‚¨è¿™äº›ä¿¡æ¯ã€‚

^code chunk-struct (1 before, 2 after)

ç°åœ¨ï¼Œè¿™ä¸ªæ•°æ®ç»“æ„åªæ˜¯ä¸€ä¸ªå­—èŠ‚æ•°ç»„çš„ç®€å•åŒ…è£…è€Œå·²ã€‚ç”±äºæˆ‘ä»¬å¹¶ä¸çŸ¥é“ç¨‹åºç¼–è¯‘æˆå­—èŠ‚ç ä»¥åï¼Œæœ‰å¤šå°‘æ¡å­—èŠ‚ç ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¹¶ä¸çŸ¥é“å­˜æ”¾è¿™äº›å­—èŠ‚ç çš„æ•°ç»„çš„å¤§å°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ•°ç»„æ˜¯å¯ä»¥åŠ¨æ€å˜åŒ–çš„ã€‚åŠ¨æ€æ•°ç»„æ˜¯æˆ‘æœ€å–œæ¬¢çš„æ•°æ®ç»“æ„ä¹‹ä¸€ã€‚å¬èµ·æ¥å°±åƒåœ¨è¯´é¦™è‰æ˜¯æˆ‘æœ€å–œæ¬¢çš„å†°æ·‡æ·‹<span name ="flavor">å£å‘³</span>ä¸€æ ·ï¼Œä½†æ˜¯ï¼Œè¯·å¬æˆ‘è¯´ã€‚åŠ¨æ€æ•°ç»„æä¾›ï¼š

<aside name="flavor">

å±±æ ¸æ¡ƒé»„æ²¹å‘³å„¿å®é™…ä¸Šæ˜¯æˆ‘çš„æœ€çˆ±ã€‚

</aside>

* é«˜é€Ÿç¼“å­˜å‹å¥½ï¼Œä¸”ç´§å¯†çš„å­˜å‚¨æ–¹å¼ã€‚

* é€šè¿‡ä¸‹æ ‡æŸ¥æ‰¾å…ƒç´ ï¼Œåªéœ€è¦å¸¸æ•°æ—¶é—´å¤æ‚åº¦ã€‚

* åœ¨æ•°ç»„æœ«å°¾æ·»åŠ å…ƒç´ ï¼Œåªéœ€è¦å¸¸æ•°æ—¶é—´å¤æ‚åº¦ã€‚

å…¶å®æˆ‘ä»¬å·²ç»åœ¨jloxä¸­ä½¿ç”¨è¿‡åŠ¨æ€æ•°ç»„äº†ï¼Œåªä¸è¿‡åœ¨Javaä¸­ï¼ŒåŠ¨æ€æ•°ç»„è—åœ¨äº†`ArrayList`çš„ä¸‹é¢ï¼Œæ¢å¥è¯è¯´ï¼ŒJavaçš„`ArrayList`çš„åº•å±‚å®ç°å°±æ˜¯åŠ¨æ€æ•°ç»„ã€‚è€Œç°åœ¨ï¼Œç”±äºCè¯­è¨€é‡Œå¹¶æ²¡æœ‰å†…ç½®åŠ¨æ€æ•°ç»„ç‰¹æ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è‡ªå·±é€ ä¸€ä¸ªã€‚å¦‚æœä½ ä¸äº†è§£åŠ¨æ€æ•°ç»„ï¼Œé‚£ä¹ˆå…¶å®å®ƒçš„æ€æƒ³éå¸¸ç®€å•ã€‚é™¤äº†æ•°ç»„æœ¬èº«ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸¤ä¸ªæ•°ï¼šæˆ‘ä»¬åŠ¨æ€åˆ†é…çš„æ•°ç»„èƒ½å®¹çº³å¤šå°‘ä¸ªå…ƒç´ ï¼ˆâ€œå®¹é‡ï¼Œcapacityâ€ï¼‰ï¼Œä»¥åŠæ•°ç»„é‡Œé¢å·²ç»å­˜æ”¾äº†å¤šå°‘ä¸ªå…ƒç´ ï¼ˆâ€œæ•°é‡ï¼Œcountâ€ï¼‰ã€‚

^code count-and-capacity (1 before, 2 after)

å½“æˆ‘ä»¬å¾€æ•°ç»„é‡Œé¢æ·»åŠ ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå¦‚æœæ•°é‡ï¼ˆcountï¼‰å°äºå®¹é‡ï¼ˆcapacityï¼‰ï¼Œè¯´æ˜æ•°ç»„ä¸­è¿˜æœ‰ç©ºé—´å¯ä»¥å­˜æ”¾æ–°çš„å…ƒç´ ã€‚ç„¶åæˆ‘ä»¬å°±å¯ä»¥å­˜æ”¾æ–°çš„å…ƒç´ ï¼Œç„¶åå°†æ•°é‡ï¼ˆcountï¼‰åŠ ä¸€ã€‚

<img src="image/chunks-of-bytecode/insert.png" alt="Storing an element in an
array that has enough capacity." />

å¦‚æœæ•°ç»„ä¸­å·²ç»æ²¡æœ‰ç©ºé—²çš„å®¹é‡æ¥å­˜æ”¾æ–°å…ƒç´ ï¼Œé‚£ä¹ˆæƒ…å†µä¼šç¨å¾®å¤æ‚ä¸€ç‚¹ï¼š

<img src="image/chunks-of-bytecode/grow.png" alt="Growing the dynamic array
before storing an element." class="wide" />

1.  é¦–å…ˆï¼Œ<span name="amortized">åˆ†é…</span>ä¸€ä¸ªæ›´å¤§å®¹é‡çš„æ–°æ•°ç»„ã€‚
2.  ç„¶åå°†æ—§æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ‹·è´åˆ°æ–°çš„æ•°ç»„ä¸­ã€‚
3.  æ›´æ–°å®¹é‡ï¼ˆ`capacity`ï¼‰å­—æ®µï¼Œå› ä¸ºæ•°ç»„çš„å®¹é‡å˜äº†ã€‚
4.  åˆ é™¤æ—§çš„æ•°ç»„ã€‚
5.  æ›´æ–°`code`å­—æ®µï¼ŒæŒ‡å‘æ–°çš„æ•°ç»„ã€‚
6.  å°†æ–°å…ƒç´ å­˜æ”¾åœ¨æ–°çš„æ•°ç»„é‡Œé¢ï¼Œå› ä¸ºæ–°çš„æ•°ç»„èƒ½æ”¾ä¸‹æ–°å…ƒç´ äº†ã€‚
7.  æ›´æ–°`count`å­—æ®µã€‚

<aside name="amortized">

å°†æ—§æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ‹·è´åˆ°æ–°çš„æ›´å¤§çš„æ•°ç»„ä¸­ï¼Œç„¶åå†æ·»åŠ æ–°çš„å…ƒç´ ï¼Œä½¿å¾—æ•´ä¸ªè¿‡ç¨‹çš„æ—¶é—´å¤æ‚åº¦æ˜¯*O(n)*ï¼Œè€Œä¸æ˜¯æˆ‘ä¸Šé¢æ‰€è¯´çš„*O(1)*ã€‚å®é™…ä¸Šï¼Œä½ åªæœ‰åœ¨æŸäº›æƒ…å†µä¸‹æ·»åŠ æ–°å…ƒç´ çš„æ—¶å€™ï¼ˆæ—§æ•°ç»„å·²ç»æ»¡çš„æƒ…å†µä¸‹ï¼‰ï¼Œæ‰ä¼šéœ€è¦åšæ‹·è´æ“ä½œã€‚å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œæ•°ç»„é‡Œé¢æ˜¯æœ‰ç©ºé—´æ¥å­˜æ”¾æ–°å…ƒç´ çš„ï¼Œæ‰€ä»¥å¹¶ä¸éœ€è¦æ‹·è´ã€‚

æƒ³è¦ç†è§£ä¸Šé¢æ‰€è¯´çš„æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæˆ–è€…è¯´è®¡ç®—æ·»åŠ ä¸€ä¸ªå…ƒç´ çš„çœŸæ­£çš„æ—¶é—´å¤æ‚åº¦æ—¶ï¼Œéœ€è¦ç ”ç©¶ä¸€ä¸‹[**å‡æ‘Šåˆ†æï¼ˆamortized analysisï¼‰**](https://en.wikipedia.org/wiki/Amortized_analysis)ã€‚å‡æ‘Šåˆ†æå‘æˆ‘ä»¬å±•ç¤ºäº†ï¼Œå½“æˆ‘ä»¬æŒ‰ç…§å½“å‰æ•°ç»„çš„å€æ•°æ¥æ‰©å¤§å½“å‰æ•°ç»„æ—¶ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰çš„æ·»åŠ æ–°å…ƒç´ çš„æ“ä½œæ‰€èŠ±è´¹çš„æ—¶é—´å‡æ‘Šä¸€ä¸‹ï¼Œæ¯ä¸ªæ·»åŠ æ–°å…ƒç´ çš„æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯*O(1)*ã€‚

</aside>

æˆ‘ä»¬çš„ç»“æ„ä½“å·²ç»å†™å¥½äº†ï¼Œç°åœ¨è®©æˆ‘ä»¬æ¥å®ç°ä¸€äº›å‡½æ•°ï¼Œèƒ½å¤Ÿæ¥æ“ä½œåŠ¨æ€æ•°ç»„çš„ç»“æ„ä½“ã€‚Cè¯­è¨€æ²¡æœ‰æ„é€ å™¨ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å£°æ˜ä¸€ä¸ªå‡½æ•°æ¥åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å—ï¼ˆchunkï¼‰ã€‚

^code init-chunk-h (1 before, 2 after)

åƒä¸‹é¢è¿™æ ·å®ç°å°±å¥½ï¼š

^code chunk-c

åŠ¨æ€æ•°ç»„æœ€å¼€å§‹å®Œå…¨æ˜¯ç©ºçš„ã€‚æˆ‘ä»¬ç”šè‡³éƒ½æ²¡æœ‰åˆ†é…ä¸€ä¸ªæ•°ç»„å‡ºæ¥å‘¢ã€‚æƒ³è¦åœ¨æ•°ç»„æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„å‡½æ•°ã€‚

^code write-chunk-h (1 before, 2 after)

è¿™å°±æ˜¯æœ‰è¶£çš„äº‹æƒ…å‘ç”Ÿçš„åœ°æ–¹ã€‚

^code write-chunk

æˆ‘ä»¬éœ€è¦åšçš„ç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯çœ‹ä¸€ä¸‹å½“å‰çš„æ•°ç»„æ˜¯å¦æœ‰å¯ä»¥å®¹çº³æ–°å…ƒç´ çš„ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯å®¹é‡å¤Ÿä¸å¤Ÿã€‚å¦‚æœæ²¡ç©ºé—´äº†ï¼Œé‚£æˆ‘ä»¬é¦–å…ˆè¦è®©æ•°ç»„å˜å¤§ï¼Œè¿™æ ·å°±æœ‰ç©ºé—´äº†ã€‚ï¼ˆæˆ‘ä»¬ä¼šåœ¨å¾€æ•°ç»„é‡Œæ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™å°±ç¢°åˆ°è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™æ•°ç»„æ˜¯`NULL`ï¼Œå®¹é‡`capacity`æ˜¯0ã€‚ï¼‰

æƒ³è¦è®©æ•°ç»„å˜å¤§ï¼Œé¦–å…ˆè¦æŒ‡å®šæ–°æ•°ç»„çš„å®¹é‡ï¼Œç„¶åå°†æ•°ç»„å˜å¤§åˆ°æ–°çš„å®¹é‡ã€‚è¿™äº›éƒ½æ˜¯é’ˆå¯¹å†…å­˜çš„åº•å±‚æ“ä½œï¼Œæ‰€ä»¥éœ€è¦æ–°å»ºä¸€ä¸ªæ¨¡å—æ¥å®šä¹‰å®ƒä»¬ã€‚

^code chunk-c-include-memory (1 before, 2 after)

è¿™è¶³ä»¥è®©æˆ‘ä»¬å¼€å§‹äº†ï¼š

^code memory-h

è¿™ä¸ªå®ï¼ˆmacroï¼‰æ ¹æ®å½“å‰çš„æ•°ç»„å®¹é‡è®¡ç®—å‡ºäº†ä¸€ä¸ªæ–°çš„æ•°ç»„å®¹é‡çš„å¤§å°ã€‚ä¸ºäº†è¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„æ€§èƒ½ï¼Œæœ€é‡è¦çš„éƒ¨åˆ†åœ¨äºæ•°ç»„çš„*æ‰©å±•*éœ€è¦åŸºäºæ—§æ•°ç»„çš„å¤§å°ã€‚æˆ‘ä»¬çš„æ•°ç»„å˜å¤§çš„å› å­æ˜¯2ï¼Œæ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„å› å­ã€‚1.5&times; æ˜¯å¦ä¸€ä¸ªå¸¸è§çš„é€‰æ‹©ã€‚

æˆ‘ä»¬è¿˜éœ€è¦å¤„ç†å½“å‰å®¹é‡ä¸º0çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç›´æ¥åˆ†é…ä¸€ä¸ªå…«ä¸ªå…ƒç´ å®¹é‡çš„æ•°ç»„ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå…ƒç´ çš„å¤§å°çš„æ•°ç»„ã€‚è¿™æ ·åšä¼š<span name="profile">é¿å…</span>å¤„ç†ä¸€äº›é¢å¤–çš„å†…å­˜ï¼Œå½“æ•°ç»„å¾ˆå°çš„æ—¶å€™ä¼šæœ‰ç‚¹éº»çƒ¦ã€‚å½“ç„¶å¦‚æœå­—èŠ‚ç çš„æ•°é‡ç‰¹åˆ«å°‘ï¼Œåªæœ‰ä¸€ä¸¤æ¡ï¼Œå¯èƒ½ä¼šæµªè´¹ä¸€ç‚¹å†…å­˜ã€‚

<aside name="profile">

åœ¨æœ¬ä¹¦ä¸­ï¼Œæˆ‘éšæ„é€‰æ‹©äº†8è¿™ä¸ªæ•°å­—ã€‚å¤§éƒ¨åˆ†åŠ¨æ€æ•°ç»„çš„å®ç°éƒ½æœ‰ä¸€ä¸ªç±»ä¼¼äº8è¿™æ ·çš„æœ€å°é˜ˆå€¼ã€‚å¦‚æœæƒ³è¦ä¸ºçœŸå®ä¸–ç•Œçš„ç¼–ç¨‹è¯­è¨€é€‰æ‹©ä¸€ä¸ªåŠ¨æ€æ•°ç»„çš„æœ€å°é˜ˆå€¼ï¼Œéœ€è¦åœ¨åŠ¨æ€æ•°ç»„æ‰©å¼ çš„æ€§èƒ½å’Œç©ºé—´çš„æµªè´¹ä¹‹é—´åšä¸€ä¸ªæƒè¡¡ï¼Œçœ‹é˜ˆå€¼é€‰æ‹©å¤šå¤§æ€§èƒ½æœ€å¥½ï¼Œåˆä¸ä¼šå¤ªæµªè´¹ç©ºé—´ã€‚

</aside>

ä¸€æ—¦æˆ‘ä»¬çŸ¥é“äº†æƒ³è¦çš„æ•°ç»„å®¹é‡ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨`GROW_ARRAY()`æ–¹æ³•å°†æ•°ç»„æ‰©å¤§åˆ°é‚£ä¸ªæ•°ç»„å®¹é‡ã€‚

^code grow-array (2 before, 2 after)

ä¸Šé¢çš„å®å®é™…ä¸Šæ˜¯å¯¹`reallocate()`æ–¹æ³•çš„åŒ…è£…ï¼ŒçœŸæ­£å·¥ä½œçš„å‡½æ•°æ˜¯`reallocate()`æ–¹æ³•ã€‚å®è¦åšçš„äº‹æƒ…å°±æ˜¯ç¡®å®šæ•°ç»„ä¸­å…ƒç´ çš„ç±»å‹æ‰€å ç”¨å†…å­˜çš„å¤§å°ï¼ˆä¾‹å¦‚ï¼Œintå ç”¨4å­—èŠ‚ï¼‰ã€‚ç„¶åå¯¹ç»“æœç±»å‹`void*`åšå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè½¬æˆæŒ‡å‘æ­£ç¡®ç±»å‹çš„æŒ‡é’ˆã€‚

`reallocate()`æ–¹æ³•æ˜¯æˆ‘ä»¬åœ¨cloxä¸­ç”¨æ¥åšæ‰€æœ‰åŠ¨æ€å†…å­˜ç®¡ç†çš„å”¯ä¸€æ–¹æ³•â€”â€”åˆ†é…å†…å­˜ï¼Œé‡Šæ”¾å†…å­˜ï¼Œä»¥åŠæ”¹å˜ä¸€ä¸ªå·²æœ‰å†…å­˜çš„å¤§å°ã€‚é€šè¿‡ä¸€ä¸ªæ–¹æ³•å®Œæˆæ‰€æœ‰çš„å†…å­˜æ“ä½œå¯¹äºæˆ‘ä»¬åé¢ç¨‹åºçš„ç¼–å†™æ˜¯éå¸¸é‡è¦çš„ï¼Œç‰¹åˆ«æ˜¯å½“æˆ‘ä»¬ç¼–å†™åƒåœ¾æ”¶é›†å™¨æ—¶ã€‚å› ä¸ºåƒåœ¾æ”¶é›†å™¨éœ€è¦è·Ÿè¸ªå½“å‰ğŸˆ¶ï¸å¤šå°‘å†…å­˜å·²ç»è¢«ä½¿ç”¨äº†ã€‚

ä¼ å…¥æ–¹æ³•çš„ä¸¤ä¸ªæœ‰å…³å¤§å°çš„å‚æ•°ï¼Œç”¨æ¥æ§åˆ¶åˆ°åº•åšå“ªä¸€ç§æ“ä½œï¼š

<table>
  <thead>
    <tr>
      <td>oldSize</td>
      <td>newSize</td>
      <td>Operation</td>
    </tr>
  </thead>
  <tr>
    <td>0</td>
    <td>Non&#8209;zero</td>
    <td>Allocate new block.</td>
  </tr>
  <tr>
    <td>Non&#8209;zero</td>
    <td>0</td>
    <td>Free allocation.</td>
  </tr>
  <tr>
    <td>Non&#8209;zero</td>
    <td>Smaller&nbsp;than&nbsp;<code>oldSize</code></td>
    <td>Shrink existing allocation.</td>
  </tr>
  <tr>
    <td>Non&#8209;zero</td>
    <td>Larger&nbsp;than&nbsp;<code>oldSize</code></td>
    <td>Grow existing allocation.</td>
  </tr>
</table>

è¿™çœ‹èµ·æ¥éœ€è¦å¤„ç†å¾ˆå¤šè¾¹ç•Œæƒ…å†µï¼Œä½†ä¸‹é¢å°±æ˜¯æˆ‘ä»¬çš„å®ç°ï¼ˆå…¶å®å¹¶ä¸å¤æ‚ï¼‰ï¼š

^code memory-c

å½“`newSize`ä¸º0æ—¶ï¼Œæˆ‘ä»¬å°†ä¼šè°ƒç”¨`free()`æ–¹æ³•æ¥é‡Šæ”¾å†…å­˜ã€‚å¦å¤–ï¼Œæˆ‘ä»¬ä¹Ÿä¾èµ–äº†Cæ ‡å‡†åº“é‡Œçš„`realloc()`æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•å°†æ”¯æŒå†…å­˜ç®¡ç†å¤„ç†é‡Šæ”¾çš„å…¶ä»–æ–¹é¢çš„åŠŸèƒ½ã€‚å½“`oldSize`ä¸º0æ—¶ï¼Œ`realloc()`æ“ä½œå°†ç­‰åŒäºè°ƒç”¨`malloc()`ã€‚

æœ€æœ‰æ„æ€çš„æƒ…å†µå°±æ˜¯å½“`oldSize`å’Œ`newSize`éƒ½ä¸ä¸º0çš„æ—¶å€™ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬è¦ç”¨`realloc()`æ–¹æ³•æ¥æ”¹å˜ä¹‹å‰åˆ†é…çš„å†…å­˜çš„å¤§å°ã€‚å¦‚æœæ–°çš„å†…å­˜å¤§å°å°äºä¹‹å‰åˆ†é…çš„å†…å­˜å¤§å°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ³•ä»…ä»…æ˜¯<span name="shrink">æ›´æ–°</span>ä¸€ä¸‹å†…å­˜å—çš„å¤§å°ï¼Œç„¶åè¿”å›å†…å­˜å—çš„æŒ‡é’ˆï¼ˆæŒ‡å‘å†…å­˜å—çš„æŒ‡é’ˆå’ŒåŸæ¥ä¸€æ ·ï¼‰å°±å¯ä»¥äº†ã€‚å¦‚æœæ–°çš„å†…å­˜å°ºå¯¸æ¯”åŸæ¥çš„æ›´å¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¼šæ‰©å¤§å·²æœ‰å†…å­˜å—çš„å¤§å°ã€‚

åªæœ‰å½“åŸæ¥å†…å­˜å—çš„åé¢çš„å†…å­˜æ²¡æœ‰åœ¨ä½¿ç”¨æ—¶ï¼Œç›´æ¥æ‰©å¤§å†…å­˜å—çš„æ“ä½œæ‰èƒ½å¤ŸæˆåŠŸã€‚å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥ç›´æ¥æ‰©å¤§å†…å­˜å—ï¼Œé‚£ä¹ˆ`realloc()`æ–¹æ³•å°†ä¼šåˆ†é…ä¸€ä¸ª*æ–°çš„*ç¬¦åˆå°ºå¯¸å¤§å°çš„å†…å­˜å—ï¼Œç„¶åå°†æ—§å†…å­˜å—ä¸­çš„æ•°æ®æ‹·è´è¿‡æ¥ï¼Œå¹¶å°†æ—§å†…å­˜å—é‡Šæ”¾ï¼Œæœ€åè¿”å›ä¸€ä¸ªæŒ‡å‘æ–°å†…å­˜å—çš„æŒ‡é’ˆã€‚è®°ä½ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„åŠ¨æ€æ•°ç»„çš„è¡Œä¸ºã€‚

ç”±äºè®¡ç®—æœºçš„å†…å­˜æ˜¯æœ‰é™çš„ï¼Œå®ƒå¹¶ä¸æ˜¯è®¡ç®—æœºç§‘å­¦ç†è®ºä¸­å®Œç¾çš„æ•°å­¦æŠ½è±¡ï¼ˆå†…å­˜æ— é™ï¼‰ï¼Œæ‰€ä»¥å½“å†…å­˜ä¸è¶³æ—¶ï¼Œåˆ†é…å†…å­˜çš„æ“ä½œå¯èƒ½ä¼šå¤±è´¥ï¼Œä¹Ÿå°±æ˜¯`realloc()`æ–¹æ³•å¯èƒ½ä¼šè¿”å›`NULL`ã€‚æˆ‘ä»¬éœ€è¦å¤„ç†ä¸€ä¸‹è¿™ç§æƒ…å†µã€‚

^code out-of-memory (1 before, 1 after)

å¦‚æœæ— æ³•è·å–è¶³å¤Ÿçš„å†…å­˜ï¼Œæˆ‘ä»¬çš„è™šæ‹Ÿæœºå°†æ— æ³•åšä»»ä½•æœ‰ç”¨çš„äº‹æƒ…ã€‚ä½†ç°åœ¨ï¼Œæˆ‘ä»¬è‡³å°‘å¯ä»¥å‘ç°å†…å­˜ä¸è¶³çš„æƒ…å†µç„¶åç»ˆæ­¢è™šæ‹Ÿæœºè¿›ç¨‹ï¼Œè€Œä¸æ˜¯ç›´æ¥è¿”å›ä¸€ä¸ª`NULL`æŒ‡é’ˆï¼Œç„¶åä»»ç”±äº‹æƒ…å¤±æ§ã€‚

<aside name="shrink">

ç”±äºæˆ‘ä»¬ä¼ å…¥æ–¹æ³•çš„å‚æ•°ä»…ä»…æ˜¯ä¸€ä¸ªè£¸æŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘äº†å†…å­˜å—çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ã€‚é‚£â€œæ›´æ–°â€å†…å­˜å—çš„å¤§å°æ„å‘³ç€ä»€ä¹ˆå‘¢ï¼Ÿåœ¨åº•å±‚ï¼Œå†…å­˜åˆ†é…å™¨å°†ä¼šä¸ºæ¯ä¸€ä¸ªåˆ†é…å‡ºæ¥çš„å†…å­˜å—ç»´æŠ¤ä¸€ä¸ªé¢å¤–çš„ç°¿è®°ä¿¡æ¯ï¼ŒåŒ…æ‹¬å†…å­˜å—çš„å°ºå¯¸å¤§å°ã€‚

ç»™å®šä¸€ä¸ªæŒ‡å‘ä¹‹å‰åˆ†é…çš„å†…å­˜å—çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬ä¼šæ‰¾åˆ°è¿™ä¸ªå†…å­˜å—çš„ç°¿è®°ä¿¡æ¯ï¼Œè€Œè¿™å¯¹äºå¹²å‡€çš„é‡Šæ”¾è¿™å—å†…å­˜æ¥è®²æ˜¯éå¸¸å¿…è¦çš„ã€‚è¿™ä¸ªå°ºå¯¸å¤§å°çš„å…ƒæ•°æ®å°±æ˜¯`realloc()`æ–¹æ³•å°†è¦æ›´æ–°çš„ä¿¡æ¯ã€‚

å¾ˆå¤š`malloc()`çš„å®ç°éƒ½ä¼šåœ¨è¿”å›æŒ‡å‘åˆ†é…å¥½çš„å†…å­˜çš„åœ°å€å‰ï¼Œä¿å­˜å·²åˆ†é…å†…å­˜çš„å°ºå¯¸å¤§å°ã€‚

</aside>

æˆ‘ä»¬å¯ä»¥åˆ›å»ºæ–°çš„å—ï¼ˆchunkï¼‰ï¼Œç„¶åå°†æŒ‡ä»¤å†™è¿›å»ã€‚è¿™å°±å®Œäº†å—ï¼Ÿå½“ç„¶æ²¡æœ‰ã€‚æˆ‘ä»¬ç°åœ¨åœ¨ä½¿ç”¨Cè¯­è¨€ï¼Œè®°ä½ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±ç®¡ç†å†…å­˜ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦è‡ªå·±é‡Šæ”¾å†…å­˜ã€‚

^code free-chunk-h (1 before, 1 after)

å®ç°å¦‚ä¸‹ï¼š

^code free-chunk

æˆ‘ä»¬å°†æ‰€æœ‰å†…å­˜é‡Šæ”¾ï¼Œç„¶åè°ƒç”¨`initChunk()`æ–¹æ³•æ¥å°†æ‰€æœ‰å—ä¸­çš„å­—æ®µéƒ½ç½®ä¸ºç©ºï¼Œä¹Ÿå°±æ˜¯æ¢å¤åˆ°åˆå§‹çŠ¶æ€ã€‚ä¸ºäº†é‡Šæ”¾å†…å­˜ï¼Œæˆ‘ä»¬éœ€è¦å†å†™ä¸€ä¸ªå®ã€‚

^code free-array (3 before, 2 after)

å°±åƒ`GROW_ARRAY()`ä¸€æ ·ï¼Œä¸Šé¢è¿™ä¸ªå®ä¹Ÿæ˜¯å¯¹`reallocate()`æ–¹æ³•çš„åŒ…è£…ã€‚å½“å‘è¿™ä¸ªå®ä¼ å…¥çš„æ–°çš„å°ºå¯¸å¤§å°çš„å‚æ•°æ˜¯0æ—¶ï¼Œå°±ä¼šé‡Šæ”¾æ‰å†…å­˜ã€‚æˆ‘æ˜ç™½ï¼Œè¿™äº›éƒ½æ˜¯ä¸€å †çƒ¦äººçš„åº•å±‚æ“ä½œã€‚åˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬åé¢ä¼šå¤§é‡çš„ä½¿ç”¨è¿™äº›å®ï¼Œç„¶ååœ¨ä¸€ä¸ªæ›´é«˜çš„å±‚æ¬¡ä¸Šé¢ç¼–ç¨‹ã€‚å½“ç„¶åœ¨è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ„å»ºä¸€äº›æœ‰å…³å­˜å‚¨ç®¡ç†çš„åŸºç¡€è®¾æ–½ã€‚

## å¯¹æŒ‡ä»¤çš„å—è¿›è¡Œåæ±‡ç¼–

Now we have a little module for creating chunks of bytecode. Let's try it out by
hand-building a sample chunk.

^code main-chunk (1 before, 1 after)

Don't forget the include.

^code main-include-chunk (1 before, 2 after)

Run that and give it a try. Did it work? Uh... who knows? All we've done is push
some bytes around in memory. We have no human-friendly way to see what's
actually inside that chunk we made.

To fix this, we're going to create a **disassembler**. An **assembler** is an
old-school program that takes a file containing human-readable mnemonic names
for CPU instructions like "ADD" and "MULT" and translates them to their binary
machine code equivalent. A *dis*-assembler goes in the other direction -- given
a blob of machine code, it spits out a textual listing of the instructions.

We'll implement something <span name="printer">similar</span>. Given a chunk, it
will print out all of the instructions in it. A Lox *user* won't use this, but
we Lox *maintainers* will certainly benefit since it gives us a window into the
interpreter's internal representation of code.

<aside name="printer">

In jlox, our analogous tool was the [AstPrinter class][].

[astprinter class]: representing-code.html#a-(not-very)-pretty-printer

</aside>

In `main()`, after we create the chunk, we pass it to the disassembler.

^code main-disassemble-chunk (2 before, 1 after)

Again, we whip up <span name="module">yet another</span> module.

<aside name="module">

I promise you we won't be creating this many new files in later chapters.

</aside>

^code main-include-debug (1 before, 2 after)

Here's that header:

^code debug-h

In `main()`, we call `disassembleChunk()` to disassemble all of the instructions
in the entire chunk. That's implemented in terms of the other function, which
just disassembles a single instruction. It shows up here in the header because
we'll call it from the VM in later chapters.

Here's a start at the implementation file:

^code debug-c

To disassemble a chunk, we print a little header (so we can tell *which* chunk
we're looking at) and then crank through the bytecode, disassembling each
instruction. The way we iterate through the code is a little odd. Instead of
incrementing `offset` in the loop, we let `disassembleInstruction()` do it for
us. When we call that function, after disassembling the instruction at the given
offset, it returns the offset of the *next* instruction. This is because, as
we'll see later, instructions can have different sizes.

The core of the "debug" module is this function:

^code disassemble-instruction

First, it prints the byte offset of the given instruction -- that tells us where
in the chunk this instruction is. This will be a helpful signpost when we start
doing control flow and jumping around in the bytecode.

Next, it reads a single byte from the bytecode at the given offset. That's our
opcode. We <span name="switch">switch</span> on that. For each kind of
instruction, we dispatch to a little utility function for displaying it. On the
off chance that the given byte doesn't look like an instruction at all -- a bug
in our compiler -- we print that too. For the one instruction we do have,
`OP_RETURN`, the display function is:

<aside name="switch">

We only have one instruction right now, but this switch will grow throughout the
rest of the book.

</aside>

^code simple-instruction

There isn't much to a return instruction, so all it does is print the name of
the opcode, then return the next byte offset past this instruction. Other
instructions will have more going on.

If we run our nascent interpreter now, it actually prints something:

```text
== test chunk ==
0000 OP_RETURN
```

It worked! This is sort of the "Hello, world!" of our code representation. We
can create a chunk, write an instruction to it, and then extract that
instruction back out. Our encoding and decoding of the binary bytecode is
working.

## å¸¸é‡

Now that we have a rudimentary chunk structure working, let's start making it
more useful. We can store *code* in chunks, but what about *data*? Many values
the interpreter works with are created at runtime as the result of operations.
In:

```lox
1 + 2;
```

The value 3 appears nowhere in the code. However, the literals `1` and `2` do.
To compile that statement to bytecode, we need some sort of instruction that
means "produce a constant" and those literal values need to get stored in the
chunk somewhere. In jlox, the Expr.Literal AST node held the value. We need a
different solution now that we don't have a syntax tree.

### å€¼çš„è¡¨ç¤º

We won't be *running* any code in this chapter, but since constants have a foot
in both the static and dynamic worlds of our interpreter, they force us to start
thinking at least a little bit about how our VM should represent values.

For now, we're going to start as simple as possible -- we'll only support
double-precision floating point numbers. This will obviously expand over time,
so we'll set up a new module to give ourselves room to grow.

^code value-h

This typedef abstracts how Lox values are concretely represented in C. That way,
we can change that representation without needing to go back and fix existing
code that passes around values.

Back to the question of where to store constants in a chunk. For small
fixed-size values like integers, many instruction sets store the value directly
in the code stream right after the opcode. These are called **immediate
instructions** because the bits for the value are immediately after the opcode.

That doesn't work well for large or variable-sized constants like strings. In a
native compiler to machine code, those bigger constants get stored in a separate
"constant data" region in the binary executable. Then, the instruction to load a
constant has an address or offset pointing to where the value is stored in that
section.

Most virtual machines do something similar. For example, the Java Virtual
Machine [associates a *constant pool*][jvm const] with each compiled class. That
sounds good enough for clox to me. Each chunk will carry with it a list of the
values that appear as literals in the program. To keep things <span
name="immediate">simpler</span>, we'll put *all* constants in there, even simple
integers.

[jvm const]: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4

<aside name="immediate">

In addition to needing two kinds of constant instructions -- one for immediate
values and one for constants in the constant table -- immediates also force us
to worry about alignment, padding, and endianness. Some architectures aren't
happy if you try to say, stuff a 4-byte integer at an odd address.

</aside>

### å€¼çš„æ•°ç»„

The constant pool is an array of values. The instruction to load a constant
looks up the value by index in that array. As with our <span
name="generic">bytecode</span> array, the compiler doesn't know how big the
array needs to be ahead of time. So, again, we need a dynamic one. Since C
doesn't have generic data structures, we'll write another dynamic array data
structure, this time for Value.

<aside name="generic">

Defining a new struct and manipulation functions each time we need a dynamic
array of a different type is a chore. We could cobble together some preprocessor
macros to fake generics, but that's overkill for clox. We won't need many more
of these.

</aside>

^code value-array (1 before, 2 after)

As with the bytecode array in Chunk, this struct wraps a pointer to an array
along with its allocated capacity and the number of elements in use. We also
need the same three functions to work with value arrays.

^code array-fns-h (1 before, 2 after)

The implementations will probably give you dÃ©jÃ  vu. First, to create a new one:

^code value-c

Once we have an initialized array, we can start <span name="add">adding</span>
values to it.

<aside name="add">

Fortunately, we don't need other operations like insertion and removal.

</aside>

^code write-value-array

The memory-management macros we wrote earlier do let us reuse some of the logic
from the code array, so this isn't too bad. Finally, to release all memory used
by the array:

^code free-value-array

Now that we have growable arrays of values, we can add one to Chunk to store the
chunk's constants.

^code chunk-constants (1 before, 1 after)

Don't forget the include.

^code chunk-h-include-value (1 before, 2 after)

Ah, C, and its Stone Age modularity story. Where were we? Right. When we
initialize a new chunk, we initialize its constant list too.

^code chunk-init-constant-array (1 before, 1 after)

Likewise, we <span name="circle">free</span> the constants when we free the
chunk.

<aside name="circle">

It's like the circle of life.

</aside>

^code chunk-free-constants (1 before, 1 after)

Next, we define a convenience method to add a new constant to the chunk. Our
yet-to-be-written compiler could write to the constant array inside Chunk
directly -- it's not like C has private fields or anything -- but it's a little
nicer to add an explicit function.

^code add-constant-h (1 before, 2 after)

Then we implement it.

^code add-constant

After we add the constant, we return the index where the constant was appended
so that we can locate that same constant later.

### å¸¸é‡çš„æŒ‡ä»¤

We can *store* constants in chunks, but we also need to *execute* them. In a
piece of code like:

```lox
print 1;
print 2;
```

The compiled chunk needs to not only contain the values 1 and 2, but know *when*
to produce them so that they are printed in the right order. Thus, we need an
instruction that produces a particular constant.

^code op-constant (1 before, 1 after)

When the VM executes a constant instruction, it <span name="load">"loads"</span>
the constant for use. This new instruction is a little more complex than
`OP_RETURN`. In the above example, we load two different constants. A single
bare opcode isn't enough to know *which* constant to load.

<aside name="load">

I'm being vague about what it means to "load" or "produce" a constant because we
haven't learned how the virtual machine actually executes code at runtime yet.
For that, you'll have to wait until you get to (or skip ahead to, I suppose) the
[next chapter][vm].

[vm]: a-virtual-machine.html

</aside>

To handle cases like this, our bytecode -- like most others -- allows
instructions to have <span name="operand">**operands**</span>. These are stored
as binary data immediately after the opcode in the instruction stream and let us
parameterize what the instruction does.

<img src="image/chunks-of-bytecode/format.png" alt="OP_CONSTANT is a byte for
the opcode followed by a byte for the constant index." />

Each opcode determines how many operand bytes it has and what they mean. For
example, a simple operation like "return" may have no operands, where an
instruction for "load local variable" needs an operand to identify which
variable to load. Each time we add a new opcode to clox, we specify what its
operands look like -- its **instruction format**.

<aside name="operand">

Bytecode instruction operands are *not* the same as the operands passed to an
arithmetic operator. You'll see when we get to expressions that those operand
values are tracked separately. Instruction operands are a lower-level notion
that modify how the bytecode instruction itself behaves.

</aside>

In this case, `OP_CONSTANT` takes a single byte operand that specifies which
constant to load from the chunk's constant array. Since we don't have a compiler
yet, we "hand-compile" an instruction in our test chunk.

^code main-constant (1 before, 1 after)

We add the constant value itself to the chunk's constant pool. That returns the
index of the constant in the array. Then we write the constant instruction,
starting with its opcode. After that, we write the one-byte constant index
operand. Note that `writeChunk()` can write opcodes or operands. It's all raw
bytes as far as that function is concerned.

If we try to run this now, the disassembler is going to yell at us because it
doesn't know how to decode the new instruction. Let's fix that.

^code disassemble-constant (1 before, 1 after)

This instruction has a different instruction format, so we write a new helper
function to disassemble it.

^code constant-instruction

There's more going on here. As with `OP_RETURN`, we print out the name of the
opcode. Then we pull out the constant index from the subsequent byte in the
chunk. We print that index, but that isn't super useful to us human readers. So
we also look up the actual constant value -- since constants *are* known at
compile-time after all -- and display the value itself too.

This requires some way to print a clox Value. That function will live in the
"value" module, so we include that.

^code debug-include-value (1 before, 2 after)

Over in that header, we declare:

^code print-value-h (1 before, 2 after)

And here's an implementation:

^code print-value

Magnificent, right? As you can imagine, this is going to get more complex once
we add dynamic typing to Lox and have values of different types.

Back in `constantInstruction()`, the only remaining piece is the return value.

^code return-after-operand (1 before, 1 after)

Remember that `disassembleInstruction()` also returns a number to tell the
caller the offset of the beginning of the *next* instruction. Where `OP_RETURN`
was only a single byte, `OP_CONSTANT` is two -- one for the opcode and one for
the operand.

## è¡Œä¿¡æ¯

Chunks contain almost all of the information that the runtime needs from the
user's source code. It's kind of crazy to think that we can reduce all of the
different AST classes that we created in jlox down to an array of bytes and an
array of constants. There's only one piece of data we're missing. We need it,
even though the user hopes to never see it.

When a runtime error occurs, we show the user the line number of the offending
source code. In jlox, those numbers live in tokens, which we in turn store in
the AST nodes. We need a different solution for clox now that we've ditched
syntax trees in favor of bytecode. Given any bytecode instruction, we need to be
able to determine the line of the user's source program that it was compiled
from.

There are a lot of clever ways we could encode this. I took the absolute <span
name="side">simplest</span> approach I could come up with, even though it's
embarrassingly inefficient with memory. In the chunk, we store a separate array
of integers that parallels the bytecode. Each number in the array is the line
number for the corresponding byte in the bytecode. When a runtime error occurs,
we look up the line number at the same index as the current instruction's offset
in the code array.

<aside name="side">

This braindead encoding does do one thing right: it keeps the line information
in a *separate* array instead of interleaving it in the bytecode itself. Since
line information is only used when a runtime error occurs, we don't want it
between the instructions, taking up precious space in the CPU cache and causing
more cache misses as the interpreter skips past it to get to the opcodes and
operands it cares about.

</aside>

To implement this, we add another array to Chunk.

^code chunk-lines (1 before, 1 after)

Since it exactly parallels the bytecode array, we don't need a separate count or
capacity. Every time we touch the code array, we make a corresponding change to
the line number array, starting with initialization.

^code chunk-null-lines (1 before, 1 after)

And likewise deallocation:

^code chunk-free-lines (1 before, 1 after)

When we write a byte of code to the chunk, we need to know what source line it
came from, so we add an extra parameter in the declaration of `writeChunk()`.

^code write-chunk-with-line-h (1 before, 1 after)

And in the implementation:

^code write-chunk-with-line (1 after)

When we allocate or grow the code array, we do the same for the line info too.

^code write-chunk-line (2 before, 1 after)

Finally, we store the line number in the array.

^code chunk-write-line (1 before, 1 after)

### åæ±‡ç¼–è¡Œä¿¡æ¯

Alright, let's try this out with our little, uh, artisanal chunk. First, since
we added a new parameter to `writeChunk()`, we need to fix those calls to pass
in some -- arbitrary at this point -- line number.

^code main-chunk-line (1 before, 2 after)

Once we have a real front end, of course, the compiler will track the current
line as it parses and pass that in.

Now that we have line information for every instruction, let's put it to good
use. In our disassembler, it's helpful to show which source line each
instruction was compiled from. That gives us a way to map back to the original
code when we're trying to figure out what some blob of bytecode is supposed to
do. After printing the offset of the instruction -- the number of bytes from the
beginning of the chunk -- we show its source line.

^code show-location (2 before, 2 after)

Bytecode instructions tend to be pretty fine-grained. A single line of source
code often compiles to a whole sequence of instructions. To make that more
visually clear, we show a `|` for any instruction that comes from the same
source line as the preceding one. The resulting output for our hand-written
chunk looks like:

```text
== test chunk ==
0000  123 OP_CONSTANT         0 '1.2'
0002    | OP_RETURN
```

We have a three-byte chunk. The first two bytes are a constant instruction that
loads 1.2 from the chunk's constant pool. The first byte is the `OP_CONSTANT`
opcode and the second is the index in the constant pool. The third byte (at
offset 2) is a single-byte return instruction.

In the remaining chapters, we will flesh this out with lots more kinds of
instructions. But the basic structure is here, and we have everything we need
now to completely represent an executable piece of code at runtime in our
virtual machine. Remember that whole family of AST classes we defined in jlox?
In clox, we've reduced that down to three arrays: bytes of code, constant
values, and line information for debugging.

This reduction is a key reason why our new interpreter will be faster than jlox.
You can think of bytecode as a sort of compact serialization of the AST, highly
optimized for how the interpreter will deserialize it in the order it needs as
it executes. In the [next chapter][vm], we will see how the virtual machine does
exactly that.

<div class="challenges">

## æŒ‘æˆ˜

1.  Our encoding of line information is hilariously wasteful of memory. Given
    that a series of instructions often correspond to the same source line, a
    natural solution is something akin to [run-length encoding][rle] of the line
    numbers.

    Devise an encoding that compresses the line information for a
    series of instructions on the same line. Change `writeChunk()` to write this
    compressed form, and implement a `getLine()` function that, given the index
    of an instruction, determines the line where the instruction occurs.

    *Hint: It's not necessary for `getLine()` to be particularly efficient.
    Since it is only called when a runtime error occurs, it is well off the
    critical path where performance matters.*

2.  Because `OP_CONSTANT` only uses a single byte for its operand, a chunk may
    only contain up to 256 different constants. That's small enough that people
    writing real-world code will hit that limit. We could use two or more bytes
    to store the operand, but that makes *every* constant instruction take up
    more space. Most chunks won't need that many unique constants, so that
    wastes space and sacrifices some locality in the common case to support the
    rare case.

    To balance those two competing aims, many instruction sets feature multiple
    instructions that perform the same operation but with operands of different
    sizes. Leave our existing one-byte `OP_CONSTANT` instruction alone, and
    define a second `OP_CONSTANT_LONG` instruction. It stores the operand as a
    24-bit number, which should be plenty.

    Implement this function:

    ```c
    void writeConstant(Chunk* chunk, Value value, int line) {
      // Implement me...
    }
    ```

    It adds `value` to `chunk`'s constant array and then writes an appropriate
    instruction to load the constant. Also add support to the disassembler for
    `OP_CONSTANT_LONG` instructions.

    Defining two instructions seems to be the best of both worlds. What
    sacrifices, if any, does it force on us?

3.  Our `reallocate()` function relies on the C standard library for dynamic
    memory allocation and freeing. `malloc()` and `free()` aren't magic. Find
    a couple of open source implementations of them and explain how they work.
    How do they keep track of which bytes are allocated and which are free?
    What is required to allocate a block of memory? Free it? How do they make
    that efficient? What do they do about fragmentation?

    *Hardcore mode:* Implement `reallocate()` without calling `realloc()`,
    `malloc()`, or `free()`. You are allowed to call `malloc()` *once*, at the
    beginning of the interpreter's execution, to allocate a single big block of
    memory which your `reallocate()` function has access to. It parcels out
    blobs of memory from that single region, your own personal heap. It's your
    job to define how it does that.

</div>

[rle]: https://en.wikipedia.org/wiki/Run-length_encoding

<div class="design-note">

## è¯­è¨€è®¾è®¡ç¬”è®°: æµ‹è¯•ä½ è®¾è®¡çš„è¯­è¨€

We're almost halfway through the book and one thing we haven't talked about is
*testing* your language implementation. That's not because testing isn't
important. I can't possibly stress enough how vital it is to have a good,
comprehensive test suite for your language.

I wrote a [test suite for Lox][tests] (which you are welcome to use on your own
Lox implementation) before I wrote a single word of this book. Those tests found
countless bugs in my implementations.

[tests]: https://github.com/munificent/craftinginterpreters/tree/master/test

Tests are important in all software, but they're even more important for a
programming language for at least a couple of reasons:

*   **Users expect their programming languages to be rock solid.** We are so
    used to mature, stable compilers and interpreters that "It's your code, not
    the compiler" is [an ingrained part of software culture][fault]. If there
    are bugs in your language implementation, users will go through the full
    five stages of grief before they can figure out what's going on, and you
    don't want to put them through all that.

*   **A language implementation is a deeply interconnected piece of software.**
    Some codebases are broad and shallow. If the file loading code is broken in
    your text editor, it -- hopefully! -- won't cause failures in the text
    rendering on screen. Language implementations are narrower and deeper,
    especially the core of the interpreter that handles the language's actual
    semantics. That makes it easy for subtle bugs to creep in caused by weird
    interactions between various parts of the system. It takes good tests to
    flush those out.

*   **The input to a language implementation is, by design, combinatorial.**
    There are an infinite number of possible programs a user could write, and
    your implementation needs to run them all correctly. You obviously can't
    test that exhaustively, but you need to work hard to cover as much of the
    input space as you can.

*   **Language implementations are often complex, constantly changing, and full
    of optimizations.** That leads to gnarly code with lots of dark corners
    where bugs can hide.

[fault]: https://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/

All of that means you're gonna want a lot of tests. But *what* tests? Projects
I've seen focus mostly on end-to-end "language tests". Each test is a program
written in the language along with the output or errors it is expected to
produce. Then you have a test runner that pushes the test program through your
language implementation and validates that it does what it's supposed to.
Writing your tests in the language itself has a few nice advantages:

*   The tests aren't coupled to any particular API or internal architecture
    decisions of the implementation. This frees you to reorganize or rewrite
    parts of your interpreter or compiler without needing to update a slew of
    tests.

*   You can use the same tests for multiple implementations of the language.

*   Tests can often be terse and easy to read and maintain since they are
    simply scripts in your language.

It's not all rosy, though:

*   End-to-end tests help you determine *if* there is a bug, but not *where* the
    bug is. It can be harder to figure out where the erroneous code in the
    implementation is because all the test tells you is that the right output
    didn't appear.

*   It can be a chore to craft a valid program that tickles some obscure corner
    of the implementation. This is particularly true for highly-optimized
    compilers where you may need to write convoluted code to ensure that you
    end up on just the right optimization path where a bug may be hiding.

*   The overhead can be high to fire up the interpreter, parse, compile, and
    run each test script. With a big suite of tests -- which you *do* want,
    remember -- that can mean a lot of time spent waiting for the tests to
    finish running.

æˆ‘å¯ä»¥ç»§ç»­è®²ï¼Œä½†æˆ‘ä¸å¸Œæœ›å˜æˆå¸ƒé“ã€‚è€Œä¸”æˆ‘å¹¶ä¸æƒ³å‡è£…è‡ªå·±æ˜¯*å¦‚ä½•*æµ‹è¯•è¯­è¨€çš„ä¸“å®¶ã€‚æˆ‘åªæƒ³è¦ä½ åœ¨å¿ƒé‡Œå†…åŒ–æµ‹è¯•çš„é‡è¦æ€§ã€‚çœŸçš„ã€‚æµ‹è¯•ä½ çš„è¯­è¨€å§ã€‚ä½ ä¼šæ„Ÿè°¢æˆ‘çš„ã€‚

</div>
